=============================================================================
Internet Engineering Task Force (IETF)                             JETPACK
Request for Comments: MJP                                         April 2025
Category: Experimental
ISSN: 0000‑0000

                            Jetpack Protocol
                                (MJP)
=============================================================================

Status of This Memo

   This memo defines an EXPERIMENTAL specification for a compact binary
   protocol, the “Jetpack Protocol” (MJP), intended to coordinate
   real‑time communication between a single authoritative game server and
   one or more Jetpack game clients.  Distribution of this document is
   unlimited.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

=============================================================================
Table of Contents                                                    Page

   1.  Introduction .................................................    2
   2.  Message Frame and General Format .............................    3
     2.1  Header Structure ..........................................    3
     2.2  Byte Order ................................................    4
   3.  Packet Type Enumeration ......................................    4
   4.  Message Descriptions .........................................    5
     4.1  CLIENT_CONNECT ............................................    5
     4.2  SERVER_WELCOME ............................................    6
     4.3  MAP_CHUNK .................................................    6
     4.4  GAME_START ................................................    7
     4.5  CLIENT_INPUT ..............................................    8
     4.6  GAME_STATE ................................................    8
     4.7  GAME_END ..................................................    9
     4.8  CLIENT_DISCONNECT .........................................   10
     4.9  DEBUG_INFO (Optional) .....................................   10
     4.10 CLIENT_ACK ................................................   11
   5.  Reliability Mechanisms .......................................   12
   6.  Overall Flow ................................................   13
   7.  Map Format and Reassembly ....................................  14
   8.  Security Considerations ......................................  15
   9.  Conclusion ...................................................  16
   Acknowledgements .................................................  16
   Authors' Addresses ...............................................  16

=============================================================================
1.  Introduction

   The Jetpack Protocol (MJP) orchestrates game state synchronisation
   between an authoritative server and multiple game clients for a
   side‑scrolling arcade title inspired by “Jetpack Joyride”.  Built
   atop TCP, MJP employs a fixed four‑byte header (Magic, Type, Length)
   followed by a message‑specific payload.  The design goals are:

   *   Robustness – simple validation via a magic byte and explicit
       length field.
   *   Modularity  – extensible packet types and optional feature blocks.
   *   Low Latency – minimal framing overhead and compact binary fields.
   *   Reliability – explicit acknowledgment of messages to ensure delivery.
   *   Ease of Implementation – all integers are big‑endian, and the
       header is uniform across messages.

   Core features shipped in this specification include:

   *   Client identification and welcome handshake.
   *   Chunked map transfer from server to clients.
   *   Explicit game start trigger after required players connect.
   *   Bit‑mask input delivery from client to server.
   *   Authoritative game‑state broadcasts (with server tick counter).
   *   Deterministic game end and graceful disconnect.
   *   Bidirectional debug messages when clients/servers run with ‑d.
   *   Client acknowledgment of server messages for reliability.

=============================================================================
2.  Message Frame and General Format

2.1.  Header Structure

   Every packet begins with a 4‑byte header:

     0               1               2               3
     +---------------+---------------+---------------+
     | Magic  (1 B)  | Type   (1 B)  | Length (2 B)  |
     +---------------+---------------+---------------+
     |            Payload (Length − 4 octets)        |
     +-----------------------------------------------+

   *  **Magic** – fixed value 0xAB.  A receiver MUST discard any packet
      whose Magic byte differs, and MAY close the connection.
   *  **Type**  – 1‑byte code identifying the message (see Section 3).
   *  **Length** – total packet length in octets, header included.
      Values < 4 are invalid.

2.2.  Byte Order

   All multi‑byte integer fields (e.g., Length, indices, coordinates) use
   network byte order (big‑endian).

=============================================================================
3.  Packet Type Enumeration

   Recommended baseline type codes:

   +-----------+---------------------------+
   | Type (u8) | Name                      |
   +-----------+---------------------------+
   | 0x01      | CLIENT_CONNECT            |
   | 0x02      | SERVER_WELCOME            |
   | 0x03      | MAP_CHUNK                 |
   | 0x04      | GAME_START                |
   | 0x05      | CLIENT_INPUT              |
   | 0x06      | GAME_STATE                |
   | 0x07      | GAME_END                  |
   | 0x08      | CLIENT_DISCONNECT         |
   | 0x09      | DEBUG_INFO (optional)     |
   | 0x0A      | CLIENT_ACK                |
   +-----------+---------------------------+

   Higher values are reserved for future extensions.  Implementations
   SHOULD ignore unknown packet types gracefully.

=============================================================================
4.  Message Descriptions

4.1.  CLIENT_CONNECT (0x01) – Client → Server

   Purpose:  Initiates a session and presents a preferred player ID.

   Payload:

     0               1               2
     +---------------+---------------+-------------------- ...
     | ReqID (1 B)   | NameLen (1 B) | Name ASCII [NameLen]
     +---------------+---------------+-------------------- ...

   *  **ReqID**   – desired player identifier (0 = let server choose).
   *  **NameLen** – length of Name field in octets.
   *  **Name**    – player nickname (ASCII, no NUL terminator).

4.2.  SERVER_WELCOME (0x02) – Server → Client

   Purpose:  Accepts or rejects a CLIENT_CONNECT and supplies the
   definitive player ID.

   Payload:

     0               1               2
     +---------------+---------------+-------------- ...
     | Accept (1 B)  | AssignedID(1B)| Optional data...
     +---------------+---------------+-------------- ...

   *  **Accept**   – 1 = accepted ; 0 = rejected (connection closes).
   *  **AssignedID** – final ID for this client.
   *  **Optional** – protocol version, max players, etc.

4.3.  MAP_CHUNK (0x03) – Server → Client

   Purpose:  Sends the level map in one or more fragments.

   Payload:

     0           1           2           3           4
     +-----------+-----------+-----------+-----------+----------...
     | ChunkIdx (2 B) | ChunkCnt (2 B) |   ChunkData [...]
     +-----------+-----------+-----------+-----------+----------...

   *  **ChunkIdx**  – zero‑based fragment index.
   *  **ChunkCnt**  – total number of fragments.
   *  **ChunkData** – raw slice of map bytes.

   The client assembles the full map after receiving all fragments
   [0 .. ChunkCnt‑1].

4.4.  GAME_START (0x04) – Server → Client

   Purpose:  Announces the official start of gameplay.

   Payload (example):

     0               1       2       3       4
     +---------------+-------+-------+-------+ ...
     | PlayerCnt(1B) | StartX(2B) | StartY(2B) | ...
     +---------------+-------+-------+-------+ ...

   *  **PlayerCnt** – total players in this match.
   *  **StartX/Y**  – recommended spawn coordinates.

4.5.  CLIENT_INPUT (0x05) – Client → Server

   Purpose:  Transfers current player actions.

   Payload:

     0       1       2
    +-------+-------+
    | ID(1B)| Jetpack (1B)
    +-------+-------+

   * **ID** : The player ID assigned by the server.
   * **Jetpack** : 1 = ON (ascending), 0 = OFF (falling).

4.6.  GAME_STATE (0x06) – Server → Client

### Purpose

Broadcasts authoritative positions, scores, life states, and collected bonuses (e.g., coins).

### Payload Format

    0       1       2       3       4
    +-------+-------+-------+-------+-------------...
    |   TICK (4 B)  | NumPlayers (1B) | Repeated Player Data [...]
    +-------+-------+-------+-------+-------------...

### Per‑player data block (9 bytes per player):

    ID(1B) PosX(2B) PosY(2B) Score(2B) Alive(1B) CollectedCoin(1B)

- **ID (1B)**: Unique identifier of the player.
- **PosX / PosY (2B each)**: Current position in world coordinates.
- **Score (2B)**: Current player score.
- **Alive (1B)**: 1 = alive, 0 = dead.
- **CollectedCoin (1B)**: 1 = a coin was collected this tick, 0 = no.

4.7.  GAME_END (0x07) – Server → Client

   Purpose:  Terminates the match and reports the outcome.

   Payload:

     0       1       2
     +-------+-------+---------------- ...
     |Reason(1B)|WinnerID(1B)| Score data...
     +-------+-------+---------------- ...

   *  **Reason** codes: 1 = Map complete; 2 = Death; 3 = Disconnect; etc.
   *  **WinnerID**: victorious player ID, or 0xFF for draw.

4.8.  CLIENT_DISCONNECT (0x08) – Either Direction

   Purpose:  Graceful teardown notification.

   Payload: none (Length = 4).

4.9.  DEBUG_INFO (0x09) – Optional, Bidirectional

   Purpose:  Carries arbitrary debug text when the application is run
   with the ‑d flag.

   Payload:

     0           1
     +-----------+-----------+----------...
     | Len (2 B) | DebugData[Len]
     +-----------+-----------+----------...

4.10.  CLIENT_ACK (0x0A) – Client → Server

   Purpose:  Acknowledges receipt of a server packet and provides feedback
   about client state.

   Payload:

     0       1       2       3       4       5       6
     +-------+-------+-------+-------+-------+-------+
     | ID(1B)|AckType(1B)|    Timestamp (4 B)        |
     +-------+-------+-------+-------+-------+-------+

   * **ID (1B)**      : The client's player ID.
   * **AckType (1B)** : The packet type being acknowledged.
   * **Timestamp (4 B)** : For GAME_STATE packets, the tick being 
                        acknowledged; for other packet types, zero.

=============================================================================
5.  Reliability Mechanisms

   The Jetpack Protocol implements reliability mechanisms to ensure proper
   message delivery despite using TCP as its transport layer:

   * **Explicit Acknowledgments**: Clients MUST acknowledge each received
     server message with a CLIENT_ACK packet. This ensures the server knows
     when important state updates have been received by clients.

   * **Input vs. Acknowledgment**: When a client has no active input 
     (jetpack off), it sends a CLIENT_ACK packet instead of a CLIENT_INPUT
     packet to acknowledge received game state. When the client has active
     input (jetpack on), the CLIENT_INPUT packet serves as both an input
     and an implicit acknowledgment.

   * **Timeliness**: Clients should send either CLIENT_INPUT or CLIENT_ACK
     packets within 50ms of receiving a GAME_STATE packet to maintain 
     responsive gameplay.

   * **Server Retransmission**: Servers MAY retransmit unacknowledged 
     critical packets (e.g., MAP_CHUNK, GAME_START) if no CLIENT_ACK is
     received within a reasonable timeout period.

   This system provides TCP-like reliability guarantees for the protocol
   while maintaining the responsiveness needed for real-time gameplay.

=============================================================================
6.  Overall Flow

   1.  **TCP Connect**           – client opens a stream to server.
   2.  **CLIENT_CONNECT**        – client proposes an ID and name.
   3.  **SERVER_WELCOME**        – server accepts or refuses; assigns ID.
   4.  **CLIENT_ACK**            – client acknowledges SERVER_WELCOME.
   5.  **MAP_CHUNK**×N           – server streams the level map.
   6.  **CLIENT_ACK**×N          – client acknowledges each MAP_CHUNK.
   7.  **GAME_START**            – server signals game commencement.
   8.  **CLIENT_ACK**            – client acknowledges GAME_START.
   9.  **Gameplay Loop**:
       • server → GAME_STATE     – each simulation tick.
       • client → CLIENT_INPUT   – if jetpack is active.
       • client → CLIENT_ACK     – if no input to send.
       • optional DEBUG_INFO.
   10. **GAME_END**              – server declares winner / reason.
   11. **CLIENT_ACK**            – client acknowledges GAME_END.
   12. **CLIENT_DISCONNECT**     – either side ends the session.

=============================================================================
7.  Map Format and Reassembly

   MJP does not prescribe a single map encoding for **ChunkData**.  Two
   commonly implemented schemes are:

   * **ASCII** – each line of symbols ('.', '#', 'C', etc.) stored as a
     chunk.
   * **Binary** – width (2 B) + height (2 B) followed by tile bytes
     (0 = empty, 1 = wall, 2 = coin, 3 = hazard).

   Servers typically split the on‑disk representation into ≈512‑byte
   fragments, populate ChunkCnt accordingly, and transmit sequentially.
   Clients buffer fragments until all indices are present, then build
   the in‑memory level.

=============================================================================
8.  Security Considerations

   * **Authoritative Server** – all collision detection, scoring, and
     death logic occur on the server.  Suspicious inputs (e.g., extreme
     coordinates) are ignored.
   * **Validation** – receivers MUST verify Magic and Length fields
     before processing a packet.
   * **Timeouts** – inactivity timers and rate limiting protect against
     stale or malicious clients.
   * **Acknowledgments** – the CLIENT_ACK system provides verification that
     game state updates are received by clients, preventing state desync.
   * **Transport Security** – MJP may be encapsulated in TLS to mitigate
     sniffing or tampering, though this is outside the present scope.

=============================================================================
9.  Conclusion

   The Jetpack Protocol combines a minimal fixed header, well‑defined
   packet types, explicit acknowledgment mechanisms, and optional extensions 
   to deliver a clear, efficient, reliable, and extensible foundation for 
   two‑player Jetpack gameplay. Adherence to this RFC enables cross‑team 
   interoperability and facilitates future evolution.

=============================================================================
Acknowledgements

   The authors thank the Jetpack project contributors for feedback and
   testing assistance.

Authors' Addresses

   Jetpack Networking Working Group
   <jetpack_santi_péa@void.never>

=============================================================================
End of Jetpack Protocol (MJP) RFC
=============================================================================
